---
title: "phenology_results_v5"
author: "Pat Dumandan"
---

```{r setup, include=FALSE}
library(dplyr)
library(tidyr)
library(portalr)
library(ggplot2)
library(lubridate)
library(reshape2)
library(splines)
library(rstan)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

source("https://raw.githubusercontent.com/patdumandan/ReproPhenology/main/RScripts/data_cleaning_functions_Supp.R?token=ALERW4LPJPSOMYGSVCJRUS3AUPBRQ")
```  

I. Data Preparation  

Notes:  
* use Sarah's code to check for bad tags, bad periods and remove them  
* use only data from 1988-2014 (period when the plot assignments were fairly constant)  
* use only plot-level data from 18 plots (control and exclosure): 1, 2, 4, 8, 9, 11, 12, 14, 17, 22,3, 6, 13, 15, 18, 19, 20, 21 * proportion of breeders is the number of individuals of a given species and sex in a given plot that exhibits reproductive characteristics divided by the total number of individuals of a given species and sex in a given plot  
* for months when no observations on reproductive individuals were made, set at 0 (not really account for detection bias)  
* lag of 1 set for NDVI and precipitation  
* all variables except month were standardized (centered each value on the mean and divide by two SDs, Gelman 2008) 

```{r warning=FALSE, message=FALSE, echo=FALSE}
####load cleaned individual-level data####
Portal_data=summarize_individual_rodents(
  clean = TRUE,
  type = "Rodents",
  length = "all",
  unknowns = FALSE,
  fillweight = FALSE,
  min_plots = 1,
  min_traps = 1,
  download_if_missing = TRUE,
  quiet = FALSE
)%>%filter(!is.na(sex),!(treatment=="spectabs"), !(year<1988), !(year>2014), 
           plot %in%c(1, 2, 4, 8, 9, 11, 12, 14, 17, 22,3, 6, 13, 15, 18, 19, 20, 21))
#Note: 18 plots included based on Ellen's paper

#add note5 column to filter out dead indivs####

Portal_rodent=read.csv("https://raw.githubusercontent.com/patdumandan/PortalData/master/Rodents/Portal_rodent.csv")
Portal_data_indiv=left_join(Portal_data, Portal_rodent)%>%
  select(period, month, day, year, treatment, plot, stake, species, sex, reprod, age, testes, vagina, pregnant, nipples, lactation, hfl, wgt,tag,note2, note5)

#assign tag IDs for untagged individuals (0 and NA in tag column)####

all_tag=id_unknowns(Portal_data_indiv, 19) 

#find and remove bad periods (periods with only one day of trapping)####

Portal_rodent_trapping= read.csv("https://raw.githubusercontent.com/patdumandan/PortalData/master/Rodents/Portal_rodent_trapping.csv")
tdat=Portal_rodent_trapping%>%group_by(period)%>%summarise(count=sum(sampled))%>%arrange(count)
bad_periods <- filter(tdat, count < 20) #based on Sarah's code
bad_periods <- as.list(bad_periods$period)

Portal_no_badperiod=all_tag[-which(all_tag$period %in%bad_periods),]%>%
  mutate(tag=as.character(tag)) #necessary so function for starred and duplicate tags will not break

#check quality of tags####

#make sure that records with * in note2 are recognized as new individuals

tags = unique(Portal_no_badperiod$tag)
star_tags = starred_tags(dat=Portal_no_badperiod, tags=tags, spp_col=8, tag_col=19)

#locate dead individuals
tags=unique(star_tags$tag)
dead_dat=is_dead(dat=star_tags, tags=tags, spp_col=8, tag_col=19)

# locate records of duplicated tags
tags=unique(dead_dat$tag)
dup_dat= is_duplicate_tag(dat=dead_dat, tags=tags, spp_col=8, tag_col=19) #returns a list of 2
duptags = unique(dup_dat$bad$tag)
no_dup = dup_dat$data[-which(dup_dat$data$tag %in% duptags),] #delete rows flagged as duplicates without clear resolution

# identify records where multiple indivs share same tag in same period
tags = unique(no_dup$tag)
same = same_period(no_dup, tags)

#eliminate tags that appear more than once in the same period - questionable data
sametags = unique(same$tag)
Portal_no_same= no_dup[-which(no_dup$tag %in% sametags),]

# "clean" data

Portal_clean=subsetDat(Portal_no_same)

#Note: this analysis does not necessarily follow the capture history of 
#individuals, what we want are just the event IDs/observations of reprod.
#characteristics to determine peak timing of breeding events

#PB DATASET####

#males####

portal_male=Portal_clean%>%filter(sex=="M", !is.na(sex), !is.na(treatment)) 

repro_male=portal_male%>%
  filter(testes==c("S", "M", "R"))

PB=repro_male%>%
  filter(species=="PB", wgt>=18)

#get count of reproductive males per month per year per trt
pb_dat=PB%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for MALES per month per year per trt
total_PB=portal_male%>%
  filter(species=="PB")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male was recorded
total_proportion=right_join(pb_dat, total_PB)%>%
  mutate(proportion=reproductive/abundance, sex="male")%>%
  arrange(proportion)

total_proportion[is.na(total_proportion)] <- 0 #set non-detects to 0

#females####

portal_female=Portal_clean%>%filter(sex=="F") #49% of individuals are males

repro_female=portal_female%>%
  filter(vagina==c("S", "P", "B")| pregnant=="P" | 
           nipples==c("R", "E", "B") | lactation=="L")

PBf=repro_female%>%
  filter(species=="PB", wgt >=21)%>%
  arrange(wgt)

#get count of reproductive males per month per year per trt
pbf_dat=PBf%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for each species per month per year per trt
total_PBf=portal_female%>%
  filter(species=="PB")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male was recorded
total_proportion_f=right_join(pbf_dat, total_PBf)%>%
  mutate(proportion=reproductive/abundance, sex="female")%>%
  arrange(proportion)

total_proportion_f[is.na(total_proportion_f)] <- 0 #set non-detects to 0

PB_all=rbind(total_proportion, total_proportion_f)
PB_all=as.data.frame(PB_all)%>%
  mutate(species="PB")

#PP DATASET####

#males####

PP=repro_male%>%
  filter(species=="PP", wgt>=13)%>%
  arrange(wgt)

#get count of reproductive males per month per year per trt
PP_dat=PP%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for MALES per month per year per trt
total_PP=portal_male%>%
  filter(species=="PP")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male were recorded
total_proportion_pp_m=right_join(PP_dat, total_PP)%>%
  mutate(proportion=reproductive/abundance, sex="male")%>%
  arrange(proportion)

total_proportion_pp_m[is.na(total_proportion_pp_m)] <- 0 #set non-detects to 0

#females####

portal_female=Portal_clean%>%filter(sex=="F") #49% of individuals are males

repro_female=portal_female%>%
  filter(vagina==c("S", "P", "B")| pregnant=="P" | nipples==c("R", "E", "B") | lactation=="L")

PPf=repro_female%>%
  filter(species=="PP",  wgt >=12)%>%
  arrange(wgt)

#get count of reproductive males per month per year per trt
PPf_dat=PPf%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for each species per month per year per trt
total_PPf=portal_female%>%
  filter(species=="PP")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male was recorded
total_proportion_pp_f=right_join(PPf_dat, total_PPf)%>%
  mutate(proportion=reproductive/abundance, sex="female")%>%
  arrange(proportion)

total_proportion_pp_f[is.na(total_proportion_pp_f)] <- 0 #set non-detects to 0

PP_all=rbind(total_proportion_pp_m, total_proportion_pp_f)
PP_all=as.data.frame(PP_all)%>%
  mutate(species="PP")

#DM DATASET####

#males####

portal_male=Portal_no_badperiod%>%filter(sex=="M") 

repro_male=portal_male%>%
  filter(testes==c("S", "M", "R"))

DM=repro_male%>%
  filter(species=="DM", wgt>=22)

#get count of reproductive males per month per year per trt
DM_dat=DM%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for MALES per month per year per trt
total_DM=portal_male%>%
  filter(species=="DM")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male was recorded
total_proportion_dm_m=right_join(DM_dat, total_DM)%>%
  mutate(proportion=reproductive/abundance, sex="male")%>%
  arrange(proportion)

total_proportion_dm_m[is.na(total_proportion_dm_m)] <- 0 #set non-detects to 0

#females####

DMf=repro_female%>%
  filter(species=="DM", wgt>=27)%>%arrange(wgt)

#get count of reproductive males per month per year per trt
DMf_dat=DMf%>%
  group_by(month, year, treatment)%>%
  summarise(reproductive=n())

#get total observed abundance for each species per month per year per trt
total_DMf=portal_female%>%
  filter(species=="DM")%>%
  group_by(month,year, treatment)%>%
  summarise(abundance=n())

#calculate proportion
#this creates NAs for months when no reproductive male was recorded
total_proportion_dm_f=right_join(DMf_dat, total_DMf)%>%
  mutate(proportion=reproductive/abundance, sex="female")%>%
  arrange(proportion)

total_proportion_dm_f[is.na(total_proportion_dm_f)] <- 0 #set non-detects to 0

DM_all=rbind(total_proportion_dm_m, total_proportion_dm_f)
DM_all=as.data.frame(DM_all)%>%
  mutate(species="DM")

#combine PB, PP and DM datasets####
all_sp=rbind(PB_all, PP_all, DM_all)

#add ndvi and ppt monthly data####

prod=ndvi(level="monthly", sensor="landsat", fill=TRUE)

prod2=prod%>%
  mutate(year=year(date), month=month(date))

ppt=weather(level="monthly", fill=TRUE)%>%select(year,month,precipitation)

all_prod=right_join(prod2,all_sp)
all_prod_ppt=right_join(ppt, all_prod)%>%filter(!is.na(precipitation), !is.na(ndvi))

#add biomass data####
bmass=biomass(level="Plot", type="Rodents",
              clean=TRUE, plots="all", time="date", shape="crosstab")


DO_bmass=bmass%>%select(DO, plot, treatment, censusdate)%>%
  filter(!(treatment%in%c("removal", "spectabs")))%>%
  mutate(month=month(censusdate), date=day(censusdate), year=year(censusdate))%>%
  group_by(month, year, treatment)%>%
  summarise(bmass_DO=sum(DO))

DS_bmass=bmass%>%select(DS, plot, treatment, censusdate)%>%
  filter(!(treatment%in%c("removal", "spectabs")))%>%
  mutate(month=month(censusdate), date=day(censusdate), year=year(censusdate))%>%
  group_by(month, year, treatment)%>%
  summarise(bmass_DS=sum(DS))

DM_bmass=bmass%>%select(DM, plot, treatment, censusdate)%>%
  filter(!(treatment%in%c("removal", "spectabs")))%>%
  mutate(month=month(censusdate), date=day(censusdate), year=year(censusdate))%>%
  group_by(month, year, treatment)%>%
  summarise(bmass_DM=sum(DM))

PB_bmass=bmass%>%select(PB, plot, treatment, censusdate)%>%
  filter(!(treatment%in%c("removal", "spectabs")))%>%
  mutate(month=month(censusdate), date=day(censusdate), year=year(censusdate))%>%
  group_by(month, year, treatment)%>%
  summarise(bmass_PB=sum(PB))

PP_bmass=bmass%>%select(PP, plot, treatment, censusdate)%>%
  filter(!(treatment%in%c("removal", "spectabs")))%>%
  mutate(month=month(censusdate), date=day(censusdate), year=year(censusdate))%>%
  group_by(month, year, treatment)%>%
  summarise(bmass_PP=sum(PP))

all_bmass11=left_join(all_prod_ppt,DM_bmass, by=c("month", "year", "treatment"))
all_bmass12=left_join(all_bmass11,DO_bmass, by=c("month", "year", "treatment"))
all_bmass13=left_join(all_bmass12,DS_bmass, by=c("month", "year", "treatment"))
all_bmass2=left_join(all_bmass13,PB_bmass, by=c("month", "year", "treatment"))
all_bmass3=left_join(all_bmass2,PP_bmass, by=c("month", "year", "treatment"))%>%
  mutate(DIPO_bmass=rowSums(.[12:14]))

# adding lags of weather variables####
var_lag=all_bmass3%>%
  mutate(month=as.integer(month), lag_month=month-1)%>%
  select(lag_month, ndvi, precipitation, month, year)%>%
  rename(lag_ndvi=ndvi, lag_ppt=precipitation)

var_lag2=left_join(all_bmass3, var_lag, by=c("month"="lag_month", "year"))%>%
  distinct()%>%filter(!is.na(lag_ndvi), !is.na(lag_ppt), !is.na(bmass_PB),
                      !is.na(bmass_PP), !is.na(DIPO_bmass))

#standardize variables####

var_lag2$years=(var_lag2$year-mean(var_lag2$year))/(2*sd(var_lag2$year))
var_lag2$ndvis=(var_lag2$lag_ndvi-mean(var_lag2$lag_ndvi))/(2*sd(var_lag2$lag_ndvi))
var_lag2$ppts=(var_lag2$lag_ppt-mean(var_lag2$lag_ppt))/(2*sd(var_lag2$lag_ppt))
var_lag2$dipos=(var_lag2$DIPO_bmass-mean(var_lag2$DIPO_bmass))/(2*sd(var_lag2$DIPO_bmass))
var_lag2$pbs=(var_lag2$bmass_PB-mean(var_lag2$bmass_PB))/(2*sd(var_lag2$bmass_PB))
var_lag2$pps=(var_lag2$bmass_PP-mean(var_lag2$bmass_PP))/(2*sd(var_lag2$bmass_PP))

#visualization####
pb_plot=var_lag2%>%filter(species=="PB")
pp_plot=var_lag2%>%filter(species=="PP")
dm_plot=var_lag2%>%filter(species=="DM")

head(var_lag2)
```  
II. Analyses  
*Goal*: Reconstruct breeding phenology of male and female PBs, PPs, and DMs in different biotic contexts (control vs k-rat exclosure) and determine the association between breeding odds and abiotic (i.e., NDVI, precipitation) and biotic (biomass of PB, PP, and all k-rats(DO,DM,DS)) factors.  

*Models*:  
* build species- and sex- specific GAMs with increasing levels of complexity (Note: P(breeding)=proportion of individuals exhibiting reproductive characteristics)  
**M1 (abiotic only model)**: P(breeding)~ s(month)+ s(year)+ lag_ndvi + lag_precipitation  
**M2 (abiotic + intraspecific competition)**: P(breeding) ~ s(month)+ s(year)+ lag_ndvi + lag_precipitation + biomass of given population (e.g., if model for PBs, biomass of PBs)  
**M3 (abiotic + intra- and interspecific competition)**: P(breeding) ~ s(month)+ s(year)+ lag_ndvi + lag_precipitation + biomass of given population (e.g., if model for PBs, biomass of PBs) + biomass of other populations (Note: for biomass of dominant competitors, it is the total biomass for all k-rat species (DO,DM,DS))  

*Modelling approaches*:  
**mod1**: GAM through mgcv package  
**mod2**: spline model with normal distribution in Stan  
**mod3**: spline model with beta-binomial distribution in Stan  

A. Preliminary Analyses focused on building M1 through different modelling approaches  
*Note*: dataset used is PB females in control  

```{r message=FALSE, include=FALSE}
PB_male_con=pb_plot%>%filter(treatment=="control", sex=="male")
PB_male_ex=pb_plot%>%filter(treatment=="exclosure", sex=="male")
PB_female_con=pb_plot%>%filter(treatment=="control", sex=="female")
PB_female_ex=pb_plot%>%filter(treatment=="exclosure", sex=="female")
```  

First, visualize data so we have a point of reference  

```{r echo=F}
ggplot(PB_female_con, aes(y=proportion, x=month, col=treatment)) +
  geom_point() + 
  ylab("P(breeding)")+
  stat_smooth(method = 'gam', formula = y ~ s(x))+
  ggtitle("PB females in control")+
  scale_x_discrete(name="month", limits=c("Jan", "Feb", "Mar", "Apr","May", "Jun",
                                          "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"))+
  theme(axis.text.x= element_text(angle = 90, vjust=0.5, hjust=1),
        panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
```

1. **M1 mod1**  
This model draws from McLean and Gurlanick's paper (2020) where they built a separate GAM to reconstruct breeding phenology of PEMA and separate GLMMs to test for the relationship of breeding odds with breeding cues (i.e., photoperiod, temperature, precipitation). Not sure why they didn't just make a single GAM and set the environmental variables as linear terms. Here we use a logistic function and cubic cyclic regression spline smoothers (bs="cc" because breeding events are cyclical).  

```{r message=FALSE}
#no explicit biotic effects
mod1=mgcv::gam(proportion~s(month, bs="cc")+lag_ndvi+lag_ppt, data=PB_female_con, method = 'REML', weights = abundance, family = binomial)
```  

```{r echo=FALSE}
summary(mod1) 
```  

```{r echo=F, fig.cap="Fig.1. Partial effects plot (mod1)"}
plot(mod1, shade=T)
```  

2. **M1 mod2**  
This model is my attempt to make a simple spline model in Stan regardless of distribution (assumed to be normal). Here, I directly use the proportion data so not really weighting them properly. I am not really able to account for variation in the sample sizes (e.g., if 1 reproductive in 2 total individuals is treated similarly as 2 reproductive in 4 individuals). Here, we use the "splines" package to create the B-splines with degree set at 3 (cubic cyclic). I could probably build the b-splines directly into Stan but this seems easier, and would make the model less complex. I still have other variables to add, anyway.  

```{r message=F, warning=F}  
X1 <- PB_female_con$month
X2= PB_female_con$lag_ndvi
X3= PB_female_con$lag_ppt
B <- t(bs(X1, df=NULL, knots=NULL, degree=3, intercept = TRUE)) # creating the B-splines, degree=3 for cubic spline
num_data <- length(X1)
num_basis <- nrow(B)
Y = PB_female_con$proportion

mod2<-stan(model_code="
data { 
  int num_data; //rows of observations 
  int num_basis; //no. of basis (order-1) 
  real <lower=0,upper=1>Y[num_data]; //response variable (e.g., no.of breeding obs.)
  vector[num_data] X1; //month
  vector[num_data] X2; //ndvi 
  vector[num_data] X3; //precip 
  matrix[num_basis, num_data] B; //matrix of coefficients of splines(rows), length of X1 (columns)
} 
 
parameters { 
  row_vector[num_basis] a_raw; // smooth terms for month
  real a0; //intercept
  real ndvi_eff;
  real ppt_eff;
  real<lower=0> sigma; //error term 
  real<lower=0> tau; // for noncentered parameterization of spline coefficients
} 
 
transformed parameters { 
  row_vector[num_basis] a; //noncentered parameters of splines
  vector[num_data] Y_hat; 
  
  a = a_raw*tau;  

 Y_hat=a0*X1 + ndvi_eff*X2 + ppt_eff*X3 + to_vector(a*B);
 }

model { 
  a_raw ~ normal(0, 1); 
  tau ~ normal(0, 1); 
  sigma ~ normal(0, 1); 
  ndvi_eff~normal(0,1);
  ppt_eff~normal(0,1);
  Y~ normal(Y_hat, sigma);
  }",
iter=300, control=list(adapt_delta=0.95), 
data =list(X1 =X1, 
           X2=X2,
           X3=X3,
           B =B, 
           num_data=num_data,
           num_basis=num_basis,
           Y=Y))
```  

```{r echo=F}
print(mod2, pars=c("a0", "ndvi_eff", "ppt_eff"))
```  

```{r echo=FALSE, fig.cap="Fig.2a. spline fit over raw data (mod2)"}
#plotting splines####
ff<-extract(mod2)
Y_hat_med <- array(NA, length(Y)) #median estimate
Y_hat_ub <- array(NA, length(Y)) #upper boundary
Y_hat_lb <- array(NA, length(Y)) #lower boundary

for (i in 1:length(Y)) {
  Y_hat_med[i] <- median(ff$Y_hat[,i]);
  Y_hat_lb[i] <- quantile(ff$Y_hat[,i],probs = 0.025)
  Y_hat_ub[i] <- quantile(ff$Y_hat[,i],probs = 0.975)
}

plot(X1,Y, xaxt="n", ylab="P(breeding)", xlab="month") #plot raw data
axis(1, c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"), at=c(1:12))
lines(smooth.spline(X1, Y_hat_med), col="blue")
lines(smooth.spline(X1, Y_hat_lb), lty=2, col="red") #0.025
lines(smooth.spline(X1, Y_hat_ub), lty=2, col="red") #0.975
```  

```{r echo=FALSE, fig.cap="Fig.2b. posterior draws over raw data (mod2)"}

yrep=extract(mod2)$Y_hat
Y_hat_med <- array(NA, length(Y)) #median estimate
for (i in 1:length(Y)) {
  Y_hat_med[i] <- mean(ff$Y_hat[,i])}

#extract posterior draws####
post1=rstan::extract(mod2)$Y_hat
post1=as.data.frame(post1)
post1=t(post1)
t3=cbind(PB_female_con$month, post1)
t3=as.data.frame(t3)
t3=t3%>%
  rename("month"="V1")
t3=reshape2::melt(t3, id=c("month"))

#plot posterior draws####
plot(t3$value~t3$month, type="l", col="grey", ylim=c(0,1), xaxt="n",  ylab="P(breeding)", xlab="month")
axis(1, c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"), at=c(1:12))
points(PB_female_con$proportion~PB_female_con$month, col="blue", pch=16)
lines(smooth.spline(X1, Y_hat_med), col="red")

```

3. **M1 mod3**  
This model has added complexity by assuming a beta-binomial (BB) distribution. This may be appropriate because if we use a binomial distribution, the probabilities are fixed (proportions are fixed). But in BB models, probabilities changes from trial to trial. This will help us account for the variation in sample sizes. So, here, the proportion of breeding events (or probability of breeding/breeding odds) has a binomial distribution but this probability has a beta distribution with shape parameters.   

```{r message=F, warning=F}  

X1 <- PB_female_con$month
X2= PB_female_con$lag_ndvi
X3= PB_female_con$lag_ppt
B <- t(bs(X1, df = NULL, knots = NULL, degree=3, intercept = TRUE)) # creating B-splines using splines package
num_data <- length(X1)
num_basis <- nrow(B)
Yct = PB_female_con$reproductive

mod3<-stan(model_code="
data { 
  int num_data; //rows of observations 
  int num_basis; //no. of basis (order-1) 
  int Y[num_data]; //response variable (e.g., no.of breeding obs.)
  int n[num_data]; //total no.of indivs in plot
  vector[num_data] X1; //month
  vector[num_data] X2; //ndvi 
  vector[num_data] X3; //precip 
  matrix[num_basis, num_data] B; //matrix of coefficients of splines(rows), length of X1 (columns)
} 
 
parameters { 
  row_vector[num_basis] a_raw; // smooth terms for month
  real a0; //intercept
  real ndvi_eff;
  real ppt_eff;
  real<lower=0> sigma; //error term 
  real<lower=0> tau; // for noncentered parameterization of spline coefficients
} 
 
transformed parameters { 
  row_vector[num_basis] a; //noncentered parameters of splines
  vector <lower=0, upper=1> [num_data] Y_hat; // mean of response variable
  vector <lower=0> [num_data] a1;
  vector <lower=0> [num_data] b1;
  
  a = a_raw*tau;  
  for (i in 1: num_data){
  Y_hat = inv_logit(a0*X1 +ndvi_eff*X2+ppt_eff*X3+ to_vector(a*B)); 
  }

a1=Y_hat*tau;
b1=(1-Y_hat)*tau;
}

model { 
  a_raw ~ normal(0, 1); 
  tau ~ normal(0, 1); 
  sigma ~ normal(0, 1); 
  ndvi_eff~normal(0,1);
  ppt_eff~normal(0,1);
  Y_hat ~ beta(a1, b1);
  Y~ binomial(n, Y_hat);
}",
         iter=300, control=list(adapt_delta=0.95), 
         data =list(X1 =X1, 
                    X2=X2,
                    X3=X3,
                    n=PB_female_con$abundance,
                    B =B, 
                    num_data=num_data,
                    num_basis=num_basis,
                    Y=PB_female_con$reproductive))
```  

```{r echo=F}
print(mod3, pars=c ("a0", "ndvi_eff", "ppt_eff"))
```

```{r echo=F, fig.cap="Fig.3a. spline fit over raw data (mod3)"}

#plotting regression lines over raw data####
ff<-extract(mod3)
Y_hat_med <- array(NA, length(Y)) #median estimate
Y_hat_ub <- array(NA, length(Y)) #upper boundary
Y_hat_lb <- array(NA, length(Y)) #lower boundary

for (i in 1:length(Y)) {
  Y_hat_med[i] <- median(ff$Y_hat[,i]);
  Y_hat_lb[i] <- quantile(ff$Y_hat[,i],probs = 0.025)
  Y_hat_ub[i] <- quantile(ff$Y_hat[,i],probs = 0.975)
}

prop=PB_female_con$proportion

plot(X1,prop, xaxt="n",  ylab="P(breeding)", xlab="month") #plot raw data
axis(1, c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"), at=c(1:12))
lines(smooth.spline(X1, Y_hat_med), col="blue")
lines(smooth.spline(X1, Y_hat_ub), lty=2, col="red")
lines(smooth.spline(X1, Y_hat_lb), lty=2, col="red")
```  

```{r echo=F, fig.cap="Fig.3b. posterior draws over raw data (mod3)"}
yrep=extract(mod3)$Y_hat
Y_hat_med <- array(NA, length(Y)) #median estimate
for (i in 1:length(Y)) {
  Y_hat_med[i] <- mean(ff$Y_hat[,i])}

#plot posterior draws####
post2=rstan::extract(mod3)$Y_hat
post2=as.data.frame(post2)
post2=t(post2)
t2=cbind(PB_female_con$month, post2)
t2=as.data.frame(t2)
t2=t2%>%
  rename("month"="V1")
t2=reshape2::melt(t2, id=c("month"))

#plot posterior draws####
plot(t2$value~t2$month, type="l", col="grey", ylim=c(0,1), xaxt="n",  ylab="P(breeding)", xlab="month")
axis(1, c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"), at=c(1:12))
points(PB_female_con$proportion~PB_female_con$month, col="blue", pch=16)
lines(smooth.spline(X1, Y_hat_med), col="red")
```  

Issues:  
* adding lags result to the truncation of the dataset. I don't have December plotted. did I add the lags wrong?  
* intercept in all models are way off 
```{r}
mean(PB_female_con$proportion) #raw data
plogis(-4.01) #mod1
plogis(0) #mod2
plogis(-0.36) #mod3
```  
* how to calculate derivatives from Stan output  
* how to add multiple smooth terms in Stan  
* how important is it to add a smoothing prior?  